# -*- coding: utf-8 -*-
"""problemD.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1KQPbRuH7ZhhN2tlZ3vXLX2Hmb7sldzYC
"""

import sys
import random
import string

# --- Step 1: Generate the crossword ---
def create_crossword(words: list) -> list:
    size = 10
    grid = [['' for _ in range(size)] for _ in range(size)]

    directions = [
        (0, 1), (0, -1), (1, 0), (-1, 0),
        (1, 1), (1, -1), (-1, 1), (-1, -1)
    ]

    # Place longest words first
    words_sorted = sorted(words, key=lambda w: -len(w))

    for word in words_sorted:
        word_upper = word.upper()
        placed = False
        attempts = 0

        while not placed:
            attempts += 1
            if attempts > 1000:
                raise Exception(f"Cannot place word '{word_upper}' in the grid.")

            x = random.randint(0, size - 1)
            y = random.randint(0, size - 1)
            dx, dy = random.choice(directions)

            end_x = x + dx * (len(word_upper) - 1)
            end_y = y + dy * (len(word_upper) - 1)
            if not (0 <= end_x < size and 0 <= end_y < size):
                continue

            conflict = any(
                grid[x + dx * i][y + dy * i] not in ('', word_upper[i])
                for i in range(len(word_upper))
            )

            if not conflict:
                for i in range(len(word_upper)):
                    nx = x + dx * i
                    ny = y + dy * i
                    grid[nx][ny] = word_upper[i]
                placed = True

    # Fill empty cells with random letters
    for i in range(size):
        for j in range(size):
            if grid[i][j] == '':
                grid[i][j] = random.choice(string.ascii_uppercase)

    return grid

# --- Step 2: Find words in the grid ---
def find_words(grid, words):
    directions = [
        (0, 1), (0, -1), (1, 0), (-1, 0),
        (1, 1), (1, -1), (-1, 1), (-1, -1)
    ]
    found_words = {}
    for word in words:
        w = word.upper()
        for r in range(len(grid)):
            for c in range(len(grid[0])):
                for dx, dy in directions:
                    if all(
                        0 <= r+i*dx < len(grid) and
                        0 <= c+i*dy < len(grid[0]) and
                        grid[r+i*dx][c+i*dy] == w[i]
                        for i in range(len(w))
                    ):
                        found_words[word] = (r, c, dx, dy)
                        break
                if word in found_words:
                    break
            if word in found_words:
                break
    return found_words

# --- Main execution block. DO NOT MODIFY. ---
if __name__ == "__main__":
    try:
        # Read words from first line (comma-separated)
        words_input = input("Enter words separated by commas: ").strip()
        words = [word.strip() for word in words_input.split(',')]

        # Generate the word search puzzle
        puzzle = create_crossword(words)

        # Print the puzzle
        print("\n--- Word Search Puzzle ---")
        for row in puzzle:
            print(''.join(row))

        # Find and display word positions
        locations = find_words(puzzle, words)
        print("\n--- Word Locations ---")
        for word, (r, c, dx, dy) in locations.items():
            print(f"{word.upper()}: Start=({r},{c}), Direction=({dx},{dy})")

    except ValueError as e:
        print(f"Input Error: {e}", file=sys.stderr)
        sys.exit(1)
    except EOFError:
        print("Error: Not enough input lines provided.", file=sys.stderr)
        sys.exit(1)
    except Exception as e:
        print(f"An unexpected error occurred: {e}", file=sys.stderr)
        sys.exit(1)